# name: int main(argc, argv) { ... }
# key: main
# --
int main(int argc, char *argv[])
{
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.setf(ios_base::fixed);
  cout.precision(15);
  // modが無くてもDPを忘れない。
  // modを見たらフェルマーの小定理を思い出す。
  // 同じ遷移を繰り返すDPは行列累乗
  // 長さnの01文字列の中で1が２つ以上連続しないものの個数はFibonacci(n)
  // バックトラックの計算量は選択肢の累積
  // 平均値や中央値を最大化する問題は「答えを K 以上にできるか？」という判定問題に帰着し二分探索によって答えを求めるのが定石。
  // 負閉路を持たないことと、実行可能ポテンシャルが存在することは同値
  // nCkのkが小さければループで計算できる。
  // ABCの３種類a個b個c個を区別しないn個の並べ替えは n!/(a!b!c!)。ABC243F
  // 区間の和を見たら累積和を思い出す。ABC238E
  // DPの状態は、過去に選んだものをパラメータに持つのではなく、選ばなかった方を持つ選択肢もある。ABC238F
  // 二項係数の和
  //   nC0 + nC1 + ... + nCn = 2^n
  //   +nC0 - nC1 + ... + (-1)^n nCn = 0
  //   nが奇数 nC0 + nC2 + ... nCn-1 = nC1 + nC3 + ... nCn = 2^n-1
  //   nが偶数 nC0 + nC2 + ... nCn = nC1 + nC3 + ... nCn-1 = 2^n-1
  // 数え上げで2^nを見たら含除く原理
  // 区間を見たら0からの操作に替えて打ち消すことを考える。ABC253G
  // 1,2,3,...,nを見たら調和級数の和を思い出す。ABC272E
  $0
  return 0;
}
