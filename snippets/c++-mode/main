# name: int main(argc, argv) { ... }
# key: main
# --
int main(int argc, char *argv[])
{
  // modが無くてもDPを忘れない。
  // modを見たらフェルマーの小定理を思い出す。
  // 同じ遷移を繰り返すDPは行列累乗
  // 長さnの01文字列の中で1が２つ以上連続しないものの個数はFibonacci(n)
  // バックトラックの計算量は選択肢の累積
  // 平均値や中央値を最大化する問題は「答えを K 以上にできるか？」という判定問題に帰着し二分探索によって答えを求めるのが定石。
  // 負閉路を持たないことと、実行可能ポテンシャルが存在することは同値
  // nCkのkが小さければループで計算できる。
  // ABCの３種類a個b個c個を区別しないn個の並べ替えは n!/(a!b!c!)。ABC243F
  // 区間の和を見たら累積和を思い出す。ABC238E
  // DPの状態は、過去に選んだものをパラメータに持つのではなく、選ばなかった方を持つ選択肢もある。ABC238F
  // 二項係数の和
  //   nC0 + nC1 + ... + nCn = 2^n
  //   +nC0 - nC1 + ... + (-1)^n nCn = 0
  //   nが奇数 nC0 + nC2 + ... nCn-1 = nC1 + nC3 + ... nCn = 2^n-1
  //   nが偶数 nC0 + nC2 + ... nCn = nC1 + nC3 + ... nCn-1 = 2^n-1
  // 数え上げで2^nを見たら含除原理
  // 区間を見たら0からの操作に替えて打ち消すことを考える。ABC253G
  // 1,2,3,...,nを見たら調和級数の和を思い出す。ABC272E
  // 1,2,3,...,nを見たら累積和の累積和を思い出す。
  // 数列を見たら階差 ABC276G
  // (x^n-1)|(x-1) ABC044D
  // |a|=N,Σa=Mな数列aについて∏aiの総和はcomb(M+N-1,N+N-1)。M以下なら捨てる分を増やしてcomb(M+N,N+N)。ARC110D
  // 行き過ぎてもゴール扱いになる双六の移動回数の期待値は後ろから計算する。ABC280E
  // BFS木/DFS木 ABC281G
  // チェビシェフ距離 max(|xi-xj|, |yi-yj|, |zi-zj|, ...)
  // 列に対する操作を見たら累積和（排他的論理和含む）を思い出す、区間の中の2点に対する操作を見たらグラフを思い出す ABC155F
  // 木の2乗DP。律儀にVまで回すとO(V^3)になりそうなDPも部分木のサイズで打ち切ればO(V^2)になる。 ABC287F
  // 完全二部マッチングの個数の数え上げはNP困難だが偶奇だけなら高速に求めることができる。 ARC054C
  // 列を見たらindexのmodでグループ分けしてみる。ABC288D
  $0
  return 0;
}
