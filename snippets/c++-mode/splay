# -*- mode: snippet -*-
# name: splay tree ordered_set
# key: splaytree
# --
// splay-treeを使ったordered_set
template<typename T, class Compare = less<T>>
struct Splay {
  // ABC421F
  struct Node {
    Node* parent;
    Node* right;
    Node* left;
    T value;
    size_t sz;
    Node(T v) : value(v), parent(nullptr), left(nullptr), right(nullptr), sz(1) {}
    size_t size(void) const { return sz; }
    bool is_root(void) const { return parent == nullptr; }
    // this が parent の左子のときの右回転
    void rotate_r(void) {
      Node* x = parent;
      Node* y = parent->parent;
      if (x->left = right) right->parent = x;
      right = x;
      x->parent = this;
      x->update();
      update();
      if (parent = y) {
        if (y->left == x) y->left = this;
        if (y->right == x) y->right = this;
        y->update();
      }
      return ;
    }
    // this が parent の右子のときの左回転
    void rotate_l(void) {
      Node* x = parent;
      Node* y = parent->parent;
      if (x->right = left) left->parent = x;
      left = x;
      x->parent = this;
      x->update();
      update();
      if (parent = y) {
        if (y->left == x) y->left = this;
        if (y->right == x) y->right = this;
        y->update();
      }
      return ;
    }
    void splay(void) {
      while (!is_root()) {
        Node* x = parent;
        if (x->is_root()) {
          (x->left == this) ? rotate_r() : rotate_l();
        } else {
          Node* y = x->parent;
          if (y->left == x) {
            if (x->left == this)  { x->rotate_r(); rotate_r(); }
            else                  { rotate_l();    rotate_r(); }
          } else {
            if (x->right == this) { x->rotate_l(); rotate_l(); }
            else                  { rotate_r();    rotate_l(); }
          }
        }
      }
      return ;
    }
    void update(void) {
      sz = 1;
      if (left) sz += left->sz;
      if (right) sz += right->sz;
      return ;
    }
  };

  struct iterator {
    Node* ptr;
    iterator(Node* p) : ptr(p) {}
    iterator& operator ++ (void) {
      if (ptr->right) {
        ptr = ptr->right;
        while (ptr->left) ptr = ptr->left;
      } else {
        Node* cur = ptr;
        Node* p = ptr->parent;
        while (p && p->right == cur) { cur = p; p = p->parent; }
        ptr = p;
      }
      return *this;
    }
    T& operator * (void) {
      assert(ptr && "nullptr");
      return ptr->value;
    }
    friend bool operator == (const iterator& a, const iterator& b) { return a.ptr == b.ptr; }
    friend bool operator != (const iterator& a, const iterator& b) { return a.ptr != b.ptr; }
  };

  // 0-indexedでnth番目の頂点をsplayして返す。
  Node* kth(int nth) {
    if (nth < 0 || nodes.size() <= nth) return nullptr;
    Node* x = root();
    while (true) {
      int size_l = size(x->left);
      if (nth < size_l) x = x->left;
      else if (nth == size_l) break;
      else { nth -= size_l + 1; x = x->right; }
    }
    splay(x);
    return x;
  }

  // 木を2つに分割した根であるLとRを返す。Lのサイズがkとなるように分割する。
  pair<Node*, Node*> split(int k) {
    if (k <= 0) return make_pair(nullptr, root());
    if (nodes.size() <= k) return make_pair(root(), nullptr);
    Node* x = kth(k);
    Node* L = x->left;
    if (L) { L->parent = nullptr; }
    x->left = nullptr;
    x->update();
    return make_pair(L, x);
  }

  Node* merge(Node* L, Node* R) {
    if (!L) return R;
    if (!R) return L;
    Node* x = rightmost(L);
    splay(x);
    x->right = R;
    R->parent = x;
    x->update();
    return x;
  }

  map<T, Node*, Compare> nodes;

  Splay() = default;
  ~Splay() { for (auto [k, v]: nodes) delete v; }

  bool insert(T t, int nth) {
    if (nodes.count(t)) return false;
    nth = max(0, min<int>(nth, nodes.size()));
    Node* new_node = new Node(t);
    auto [L, R] = split(nth);
    merge(merge(L, new_node), R);
    nodes[t] = new_node;
    return true;
  }

  bool erase(T t) {
    if (!nodes.count(t)) return false;
    Node* x = nodes[t];
    splay(x);
    Node* L = x->left; if (L) L->parent = nullptr;
    Node* R = x->right; if (R) R->parent = nullptr;
    merge(L, R);
    delete x;
    nodes.erase(t);
    return true;
  }

  bool erase_nth(int nth) {
    auto itr = find_by_order(nth);
    if (itr != end()) return erase(*itr);
    else return false;
  }

  iterator find(T val) {
    if (nodes.count(val)) return iterator(nodes[val]);
    return end();
  }

  iterator find_by_order(size_t nth) {
    if (nodes.size() <= nth) return end();
    return iterator(kth(nth));
  }

  int order_by_value(T t) {
    if (!nodes.count(t)) return -1;
    splay(nodes[t]);
    return size(nodes[t]->left);
  }

  size_t size(void) const { return nodes.size(); }

  bool empty(void) const { return nodes.empty(); }

  iterator begin(void) {
    if (nodes.empty()) return end();
    Node* p = root();
    return iterator(leftmost(p));
  }

  iterator end(void) const { return iterator(nullptr); }

private:
  void splay(Node* x) { if (x) x->splay(); }

  Node* root(void) {
    if (nodes.empty()) return nullptr;
    Node* root = nodes.begin()->second;
    splay(root);
    return root;
  }

  int size(Node* x) const { return x ? x->sz : 0; }

  Node* leftmost(Node* x) const {
    if (!x) return nullptr;
    while (x->left) x = x->left;
    return x;
  }

  Node* rightmost(Node* x) const {
    if (!x) return nullptr;
    while (x->right) x = x->right;
    return x;
  }
};
